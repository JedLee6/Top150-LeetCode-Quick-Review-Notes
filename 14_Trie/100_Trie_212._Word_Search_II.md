## 100_Trie_212._Word_Search_II

Given an `m x n` `board` of characters and a list of strings `words`, return *all words on the board*.

Each word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.

 

**Example 1:**

![img](https://raw.githubusercontent.com/JedLee6/PublicPicBed/main/uPic/search1-20250719201403645-20250719201431022.jpg)

```
Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
Output: ["eat","oath"]
```

**Example 2:**

![img](https://raw.githubusercontent.com/JedLee6/PublicPicBed/main/uPic/search2.jpg)

```
Input: board = [["a","b"],["c","d"]], words = ["abcb"]
Output: []
```

 

**Constraints:**

- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 12`
- `board[i][j]` is a lowercase English letter.
- `1 <= words.length <= 3 * 104`
- `1 <= words[i].length <= 10`
- `words[i]` consists of lowercase English letters.
- All the strings of `words` are unique.

> prune /pruːn/  V-T/V-I. When you <b>prune</b>, or <b>prune</b> a tree or bush, you cut off some of the branches so that it will grow better the next year.  N. A <b>prune</b> is a dried plum.
>
> diagonally /daɪˈæɡənəli/ ADV. A <b>diagonal</b> line or movement goes in a sloping direction, for example, from one corner of a square across to the opposite corner.

## Initial Intuition

"Looking at this problem, we need to find multiple words from a given list in a 2D character board. Each word must be constructed by traversing adjacent cells, where we can move horizontally or vertically but not diagonally, and we can't reuse cells for the same word.

we can think of a few approaches to solve this:

1. **Brute force approach**: For each word in the list, search the entire board to check if it exists. This would involve a DFS/backtracking search for each word, resulting in O(W * M * N * 4^L) time complexity, where W is the number of words, M×N is the board size, and L is the maximum word length.

2. **Trie + DFS approach**: Build a Trie (prefix tree) from all the words in the list, then perform a DFS from each cell on the board. This allows us to search for all words simultaneously rather than one by one, and we can terminate early if a prefix doesn't exist in any word.

3. **Optimized Trie + DFS**: Enhance the previous approach by pruning the Trie as we find words, which reduces the search space for subsequent traversals.

Let us implement the Trie + DFS approach since it's significantly more efficient than the naive approach, especially given the constraints of up to 3*10^4 words."

## Solution: Trie + DFS with Backtracking

"I'll first implement the standard Trie + DFS solution:

1. Build a Trie from all the words in the list
2. For each cell in the board, start a DFS exploration
3. During DFS, check if the current path forms a prefix that exists in the Trie
4. If a complete word is found, add it to the result
5. Use backtracking to explore all possible paths

Let's code this up:"

```java
// First, let's define our TrieNode class to store the dictionary of words
class TrieNode {
    // An array of children nodes, indexed by character (a-z)
    TrieNode[] children;
    
    // If this node represents the end of a word, store the word here
    String word;
    
    // Constructor to initialize a new TrieNode
    public TrieNode() {
        // Initialize an array of 26 child nodes (for lowercase a-z)
        children = new TrieNode[26];
        
        // Initially, no word ends at this node
        word = null;
    }
}

class Solution {
    // Define the four possible directions for traversal: up, right, down, left
    private static final int[][] DIRECTIONS = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
    
    // Main method to find all words from the given list that exist on the board
    public List<String> findWords(char[][] board, String[] words) {
        // Initialize a list to store the found words
        List<String> result = new ArrayList<>();
        
        // Handle edge cases where the board or words array is empty
        if (board == null || board.length == 0 || words == null || words.length == 0) {
            return result;
        }
        
        // Build a Trie from the list of words for efficient prefix checking
        TrieNode root = buildTrie(words);
        
        // Get the dimensions of the board
        int m = board.length;
        int n = board[0].length;
        
        // Start a DFS from each cell in the board
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // Perform DFS starting from cell (i, j)
                dfs(board, i, j, root, result);
            }
        }
        
        // Return the list of found words
        return result;
    }
    
    // Method to build a Trie from an array of words
    private TrieNode buildTrie(String[] words) {
        // Create the root node of the Trie
        TrieNode root = new TrieNode();
        
        // Insert each word into the Trie
        for (String word : words) {
            // Start from the root for each word
            TrieNode node = root;
            
            // Process each character in the word
            for (char c : word.toCharArray()) {
                // Calculate the index for the current character (a=0, b=1, etc.)
                int index = c - 'a';
                
                // If the child node for this character doesn't exist, create it
                if (node.children[index] == null) {
                    node.children[index] = new TrieNode();
                }
                
                // Move to the child node for the next iteration
                node = node.children[index];
            }
            
            // After processing all characters, mark this node as the end of the word
            node.word = word;
        }
        
        // Return the root of the constructed Trie
        return root;
    }
    
    // DFS method to explore the board and find words
    private void dfs(char[][] board, int i, int j, TrieNode node, List<String> result) {
        // Get the dimensions of the board
        int m = board.length;
        int n = board[0].length;
        
        // Check for boundary conditions or if the cell is already visited (marked with '#')
        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] == '#') {
            return;
        }
        
        // Get the current character from the board
        char c = board[i][j];
        
        // Calculate the index for the current character
        int index = c - 'a';
        
        // If this character doesn't exist in the current Trie node, return (no valid words)
        if (node.children[index] == null) {
            return;
        }
        
        // Move to the child node corresponding to the current character
        node = node.children[index];
        
        // If we've found a complete word at this node, add it to the result
        if (node.word != null) {
            // Add the word to our result list
            result.add(node.word);
            // Set the word to null to avoid adding duplicates if we revisit this node
            node.word = null;
        }
        
        // Mark the current cell as visited by replacing it with a special character
        board[i][j] = '#';
        
        // Explore all four adjacent cells (up, right, down, left)
        for (int[] dir : DIRECTIONS) {
            // Calculate the coordinates of the adjacent cell
            int newI = i + dir[0];
            int newJ = j + dir[1];
            
            // Continue DFS from the adjacent cell
            dfs(board, newI, newJ, node, result);
        }
        
        // Restore the original character (backtracking step)
        board[i][j] = c;
    }
}
```

## Optimized Solution: Trie Pruning

"Let us now implement an optimized version that prunes the Trie as we find words. This reduces the search space for subsequent traversals, making the solution more efficient:

1. Add a count field to each TrieNode to track how many words contain this prefix
2. When a word is found, decrement the count for each node along its path
3. During DFS, skip nodes with a count of 0 as they can't lead to any more words

Here's the implementation:"

```java
// Enhanced TrieNode class with a counter to track how many words pass through each node
class TrieNode {
    // An array of children nodes, indexed by character (a-z)
    TrieNode[] children;
    
    // If this node represents the end of a word, store the word here
    String word;
    
    // Counter to track how many words pass through this node
    int count;
    
    // Constructor to initialize a new TrieNode
    public TrieNode() {
        // Initialize an array of 26 child nodes (for lowercase a-z)
        children = new TrieNode[26];
        
        // Initially, no word ends at this node
        word = null;
        
        // Initially, no words pass through this node
        count = 0;
    }
}

class Solution {
    // Define the four possible directions for traversal: up, right, down, left
    private static final int[][] DIRECTIONS = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};
    
    // Root node of the Trie, accessible to all methods
    private TrieNode root;
    
    // Main method to find all words from the given list that exist on the board
    public List<String> findWords(char[][] board, String[] words) {
        // Initialize a list to store the found words
        List<String> result = new ArrayList<>();
        
        // Handle edge cases where the board or words array is empty
        if (board == null || board.length == 0 || words == null || words.length == 0) {
            return result;
        }
        
        // Build a Trie from the list of words for efficient prefix checking
        root = buildTrie(words);
        
        // Get the dimensions of the board
        int m = board.length;
        int n = board[0].length;
        
        // Start a DFS from each cell in the board
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // Perform DFS starting from cell (i, j)
                dfs(board, i, j, root, result);
            }
        }
        
        // Return the list of found words
        return result;
    }
    
    // Method to build a Trie from an array of words
    private TrieNode buildTrie(String[] words) {
        // Create the root node of the Trie
        TrieNode root = new TrieNode();
        
        // Insert each word into the Trie
        for (String word : words) {
            // Start from the root for each word
            TrieNode node = root;
            
            // Process each character in the word
            for (char c : word.toCharArray()) {
                // Calculate the index for the current character (a=0, b=1, etc.)
                int index = c - 'a';
                
                // If the child node for this character doesn't exist, create it
                if (node.children[index] == null) {
                    node.children[index] = new TrieNode();
                }
                
                // Move to the child node for the next iteration
                node = node.children[index];
                
                // Increment the count to indicate one more word passes through this node
                node.count++;
            }
            
            // After processing all characters, mark this node as the end of the word
            node.word = word;
        }
        
        // Return the root of the constructed Trie
        return root;
    }
    
    // DFS method to explore the board and find words
    private void dfs(char[][] board, int i, int j, TrieNode node, List<String> result) {
        // Get the dimensions of the board
        int m = board.length;
        int n = board[0].length;
        
        // Check for boundary conditions or if the cell is already visited (marked with '#')
        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] == '#') {
            return;
        }
        
        // Get the current character from the board
        char c = board[i][j];
        
        // Calculate the index for the current character
        int index = c - 'a';
        
        // If this character doesn't exist in the current Trie node or its count is 0, return
        if (node.children[index] == null || node.children[index].count == 0) {
            return;
        }
        
        // Move to the child node corresponding to the current character
        node = node.children[index];
        
        // If we've found a complete word at this node, add it to the result
        if (node.word != null) {
            // Add the word to our result list
            result.add(node.word);
            
            // Store the found word before nullifying it
            String foundWord = node.word;
            
            // Set the word to null to avoid adding duplicates if we revisit this node
            node.word = null;
            
            // Remove this word from the Trie by decrementing counts along its path
            pruneWord(foundWord);
        }
        
        // Mark the current cell as visited by replacing it with a special character
        board[i][j] = '#';
        
        // Explore all four adjacent cells (up, right, down, left)
        for (int[] dir : DIRECTIONS) {
            // Calculate the coordinates of the adjacent cell
            int newI = i + dir[0];
            int newJ = j + dir[1];
            
            // Continue DFS from the adjacent cell
            dfs(board, newI, newJ, node, result);
        }
        
        // Restore the original character (backtracking step)
        board[i][j] = c;
    }
    
    // Method to remove a word from the Trie by decrementing counts along its path
    private void pruneWord(String word) {
        // Start from the root of the Trie
        TrieNode node = root;
        
        // Traverse the path of the word and decrement counts
        for (char c : word.toCharArray()) {
            // If we've already removed this branch, break
            if (node == null) break;
            
            // Move to the child node corresponding to the current character
            node = node.children[c - 'a'];
            
            // Decrement the count to indicate one fewer word passes through this node
            if (node != null) node.count--;
        }
    }
}
```

## Time and Space Complexity Analysis

"Let us analyze the time and space complexity of this solution:

### Time Complexity:

- **Building the Trie**: O(W * L) where W is the number of words and L is the average word length.
- **DFS traversal**: In the worst case, we explore from each cell on the board in all four directions up to the maximum word length. This gives us O(M * N * 4^L) where M×N is the board size and L is the maximum word length.
- **Overall**: O(W * L + M * N * 4^L)

However, the optimized version with Trie pruning significantly reduces this in practice because:
1. As we find words, we prune the Trie, which means subsequent searches have fewer paths to explore.
2. We can skip branches of the Trie that no longer contain any words.
3. We terminate early when we reach a prefix that doesn't exist in any remaining word.

### Space Complexity:
- **Trie storage**: O(W * L) for storing all words in the Trie.
- **Recursion stack**: O(L) for the maximum depth of the DFS recursion.
- **Result list**: O(W) in the worst case if all words are found.
- **Overall**: O(W * L)

### Factors influencing complexity:
1. The number of words (W) and their length (L) directly affect both time and space complexity.
2. The board dimensions (M×N) affect how many DFS traversals we start.
3. The distribution of characters on the board affects pruning efficiency - if many words share common prefixes, pruning is more effective.

### Trade-offs between approaches:
1. **Naive approach vs. Trie-based approach**:
   - The naive approach is simpler but exponentially slower when there are many words to search for.
   - The Trie-based approach requires more initial setup but becomes vastly more efficient as the number of words increases.

2. **Basic Trie vs. Pruning Trie**:
   - The basic Trie implementation is simpler but may explore unnecessary paths.
   - The pruning Trie adds some overhead for tracking counts but significantly reduces the search space, especially for larger word lists.

3. **Alternative data structures**:
   - We could use a hash map instead of an array for the Trie children, which might be more memory-efficient for sparse character sets but slightly slower for access.
   - A suffix tree could be an alternative but would be overkill for this specific problem."

## Conclusion

"The Trie + DFS approach with pruning is an elegant and efficient solution to this problem. By combining the prefix-checking capability of a Trie with the path exploration of DFS, we can simultaneously search for all words rather than checking each one individually.

The key insights are:
1. Using a Trie to efficiently check if a path forms a valid prefix of any word
2. Using DFS with backtracking to explore all possible paths on the board
3. Pruning the Trie as we find words to avoid unnecessary explorations

This solution efficiently handles the given constraints of up to 3*10^4 words with lengths up to 10, and a board of up to 12×12 cells."